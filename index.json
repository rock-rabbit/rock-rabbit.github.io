[{"categories":null,"contents":"","date":"05/27","permalink":"https://www.68wu.cn/project/mardown/","tags":null,"title":"Mardown"},{"categories":["工具"],"contents":"   介绍  NSIS 是一款老牌专业开源软件，用来制作 Windows 安装程序。它可以实现程序的安装、卸载、系统设置、文件提取等功能。因为它是基于脚本语言，所以您可以完全控制安装程序的每个部分。\nNSIS 脚本语言支持变量、函数和字符串操作，就像普通编程语言一样 - 但专为创建安装程序而设计。即使具有所有这些功能，NSIS 仍然是最小的安装程序系统。使用默认选项时，它的开销仅为 34 KB。\n   特征   开销很小（小于 40kb） 强大的脚本语言 易于使用，支持各种功能，如自定义界面、卸载程序、创建桌面快捷方式等 支持多语言 独特的压缩选项（zlib，bzip2，lzma）     安装 NSIS  在 NSIS 下载地址 下载 NSIS 安装程序，安装完成后默认会安装到 C:\\\\Program Files (x86)\\\\NSIS。需要将这个目录添加进 PATH 里，以便使用 makensis.exe 执行 nsi 脚本。\n   创建 NSIS 安装程序  创建一个 NSIS 安装程序的过程包含三个主要步骤：\n 编写 .nsi 脚本文件； 使用 makensis 编译脚本文件，makensis nsis.nsi ； 运行生成的 .exe 安装程序；  以下是一个示例脚本文件：\n;-------------------------------- ; 常规属性 ;-------------------------------- Name \u0026quot;My Application\u0026quot; OutFile \u0026quot;MyApplication Setup.exe\u0026quot; InstallDir \u0026quot;$PROGRAMFILES\\my_application\u0026quot; ;-------------------------------- ; 定义界面 ;-------------------------------- !include \u0026quot;MUI2.nsh\u0026quot; ;-------------------------------- ; 定义安装过程 ;-------------------------------- ; 安装目录选择页面 !insertmacro MUI_PAGE_DIRECTORY ; 安装过程页面 !insertmacro MUI_PAGE_INSTFILES ; 安装完成页面 !insertmacro MUI_PAGE_FINISH ; 卸载过程页面 !insertmacro MUI_UNPAGE_CONFIRM ; 卸载完成页面 !insertmacro MUI_UNPAGE_INSTFILES ;-------------------------------- ; 定义安装区段 ;-------------------------------- Section \u0026quot;MainSection\u0026quot; SEC01 SetOutPath $INSTDIR File \u0026quot;MyApplication.exe\u0026quot; SectionEnd ;-------------------------------- ; 定义卸载区段 ;-------------------------------- Section \u0026quot;Uninstall\u0026quot; SEC02 Delete $INSTDIR\\\\MyApplication.exe RMDir $INSTDIR SectionEnd 示例脚本说明：\n常规属性：\nName 定义程序名称；\nOutFile NSIS 输出文件，也就是安装文件的输出路径；\nInstallDir 安装目录；\n定义界面：引入新界面样式的头文件；\n定义安装过程：安装过程有两种，安装过程和卸载过程；\n区段 (Section) ：\n安装时可能要选择安装多个组件，区段就是定义组件的安装文件和逻辑；\n安装区段：安装区段的名字定义相对随意，除了卸载区段的名称限制其他的都是安装区段；\n卸载区段：卸载区段的名字限制：前缀为 un. 或者名字是 Uninstall 的区段；\n常量：\n$PROGRAMFILES：程序目录；\n变量：\n$INSTDIR ：安装目录；\n脚本还有很多功能，可以查看手册：\n下载中文版 NSIS.chm\n   其他示例  ; 基本信息 !define APP_NAME \u0026quot;doghead-tool\u0026quot; !define APP_LNK_NAME \u0026quot;狗头工具\u0026quot; !define APP_VERSION \u0026quot;1.0.0\u0026quot; ; 新版 UI 2.0 !include \u0026quot;MUI2.nsh\u0026quot; ; 新版安装和卸载图标 !define MUI_ICON \u0026quot;${NSISDIR}\\Contrib\\Graphics\\Icons\\orange-install.ico\u0026quot; !define MUI_UNICON \u0026quot;${NSISDIR}\\Contrib\\Graphics\\Icons\\orange-uninstall.ico\u0026quot; ; 基础信息 Name ${APP_NAME} OutFile \u0026quot;${APP_LNK_NAME} ${APP_VERSION} Setup.exe\u0026quot; InstallDir \u0026quot;$PROGRAMFILES\\${APP_NAME}\u0026quot; ; 安装完成后运行程序 !define MUI_FINISHPAGE_RUN \u0026quot;$INSTDIR\\${APP_NAME}.exe\u0026quot; !define MUI_FINISHPAGE_RUN_NOTCHECKED ; 安装完成后显示信息 !define MUI_FINISHPAGE_LINK \u0026quot;访问 rockrabbit 网站\u0026quot; !define MUI_FINISHPAGE_LINK_LOCATION \u0026quot;https://www.68wu.cn\u0026quot; ; 安装目录选择页面 !insertmacro MUI_PAGE_DIRECTORY ; 安装过程页面 !insertmacro MUI_PAGE_INSTFILES ; 安装完成页面 !insertmacro MUI_PAGE_FINISH ; 卸载过程页面 !insertmacro MUI_UNPAGE_CONFIRM ; 卸载完成页面 !insertmacro MUI_UNPAGE_INSTFILES ; 定义语言 !insertmacro MUI_LANGUAGE \u0026quot;SimpChinese\u0026quot; ; 文件打包 Section MainSetup SetOutPath $INSTDIR File \u0026quot;doghead-tool.exe\u0026quot; File \u0026quot;app.ico\u0026quot; ;创建注册信息 WriteRegStr HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; \u0026quot;DisplayName\u0026quot; \u0026quot;${APP_NAME}\u0026quot; WriteRegStr HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; \u0026quot;DisplayVersion\u0026quot; \u0026quot;${APP_VERSION}\u0026quot; WriteRegStr HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; \u0026quot;Publisher\u0026quot; \u0026quot;rockrabbit\u0026quot; WriteRegStr HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; \u0026quot;UninstallString\u0026quot; \u0026quot;$\\\u0026quot;$INSTDIR\\Uninstall.exe$\\\u0026quot;\u0026quot; WriteRegStr HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; \u0026quot;InstallLocation\u0026quot; \u0026quot;$INSTDIR\u0026quot; WriteRegStr HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; \u0026quot;DisplayIcon\u0026quot; \u0026quot;$INSTDIR\\app.ico\u0026quot; WriteRegStr HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; \u0026quot;HelpLink\u0026quot; \u0026quot;https://www.68wu.cn\u0026quot; WriteRegStr HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; \u0026quot;URLInfoAbout\u0026quot; \u0026quot;https://www.68wu.cn\u0026quot; ;创建菜单快捷方式 CreateDirectory \u0026quot;$SMPROGRAMS\\${APP_NAME}\u0026quot; CreateShortCut \u0026quot;$SMPROGRAMS\\${APP_NAME}\\${APP_LNK_NAME}.lnk\u0026quot; \u0026quot;$INSTDIR\\${APP_NAME}.exe\u0026quot; CreateShortCut \u0026quot;$STARTMENU\\${APP_NAME}\\${APP_LNK_NAME}.lnk\u0026quot; \u0026quot;$INSTDIR\\${APP_NAME}.exe\u0026quot; ;卸载程序 WriteUninstaller \u0026quot;$INSTDIR\\Uninstall.exe\u0026quot; ;创建桌面快捷方式 CreateShortCut \u0026quot;$DESKTOP\\${APP_LNK_NAME}.lnk\u0026quot; \u0026quot;$INSTDIR\\${APP_NAME}.exe\u0026quot; SectionEnd ; 卸载程序 Section Uninstall ;删除安装目录 RMDir /r \u0026quot;$INSTDIR\u0026quot; ;删除桌面快捷方式 Delete \u0026quot;$DESKTOP\\${APP_LNK_NAME}.lnk\u0026quot; ;删除注册信息 DeleteRegKey HKLM \u0026quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}\u0026quot; ;删除菜单快捷方式 Delete \u0026quot;$SMPROGRAMS\\${APP_NAME}\\${APP_LNK_NAME}.lnk\u0026quot; Delete \u0026quot;$STARTMENU\\${APP_NAME}\\${APP_LNK_NAME}.lnk\u0026quot; RMDir /r \u0026quot;$SMPROGRAMS\\${APP_NAME}\u0026quot; SectionEnd ","date":"03/11","permalink":"https://www.68wu.cn/post/tool/nsis/","tags":["工具","NSIS"],"title":"使用 NSIS 制作 Windows 安装程序"},{"categories":["工具"],"contents":"   🥣 Umami （鲜味）  Umami 是一个简单、易于使用、自托管的网络分析解决方案。\n目标是为你提供一个更友好、注重隐私的 Google Analytics 替代方案，以及一个免费、开源的付费解决方案替代方案。Umami 只收集你关心的指标，所有内容都放在一个页面上。你可以在此处查看现场演示。\n推荐使用 Umami 的原因？\n在国内有一款非常有名的网站流量分析平台：友盟（cnzz），为什么我不推荐使用它？因为友盟多次暴露出它会在免费使用它的网页中插入广告，导致我不再信任它。\nUmami 是开源的自建平台、安全、稳定，小巧，使用 Umami 就可以避免友盟这种事件的发生。\n它对于开发者来说是非常好搭建和使用的，因为它支持 docker。\n官网：https://umami.is\nUmami 支持多国语言，包括简体中文、繁体中文等等。\n   ✨ Umami 特点   简洁的分析：Umami 仅衡量你关心的重要指标：网页浏览量、使用的设备以及访问者的来源。所有内容都显示在一个易于浏览的页面上。 不限网站数量：Umami 能够一次安装就跟踪无限数量的网站。你甚至可以跟踪子域和单个 URL。 绕过广告拦截器：Umami 由你在自己的域名下托管，因此你可以有效的避免与 Google Analytics 不同的广告拦截程序。 体积小：跟踪脚本很小（只有 2KB），支持 IE 等传统浏览器。 多账户：Umami 可以用来为朋友或客户托管数据。只需创建一个单独的帐户，他们就可以开始在自己的仪表板上跟踪自己的网站。 数据公开：如果你想公开分享你的统计数据，Umami 可以为你唯一生成一个 URL。 手机友好：Umami 界面针对移动设备进行了优化，因此你可以在任何地方查看你的统计数据。 数据所有权：因为 Umami 是自托管的，所以你拥有所有数据。无需将数据交给第三方进行利用。 以隐私为中心：Umami 不收集任何个人身份信息，并对收集的所有数据进行匿名。 开源：Umami 是开源的，并根据 MIT 许可证获得许可。源代码可在 Github 上获得。     ☘️ Umami 环境要求   装有 Node.js 12 或更高版本 数据库：Umami 支持 MySQL 和 Postgresql 数据库 MySQL 数据库最低要求 5.7     🖥 在 windows 安装  如果你需要在 windows 安装 mysql 的教程请访问：传送门\n#1 获取源代码并安装软件包\n1 2 3  git clone https://github.com/mikecao/umami.git cd umami yarn install   #2 配置 Umami\n使用以下内容创建文件 .env ，是不包含括号的哦 🖐️\n1  DATABASE_URL=(connection url)   连接 URL 采用以下格式：\n1 2 3  postgresql://username:mypassword@localhost:5432/mydb mysql://username:mypassword@localhost:3306/mydb   #3 构建应用程序\n1  yarn build   #4 创建数据库表\n1  yarn update-db   这会创建一个初始账户：admin 和密码：umami\n#5 启动应用程序\n1  yarn start   默认情况下，启动完成后你可以直接访问 http://localhost:3000 ，你想改变运行端口你可以修改 package.json 文件，如下：\n在 start-next 键内容后面添加 -p 2157 就可以把启动端口改为 2157。这其实是 next 的用法，其他用法请参考 next 手册：传送门\n如果你想使用域名来访问 umami 服务，可以参考 nginx 的 proxy 功能：传送门\n   🐳 在 docker 安装  要构建 Umami 容器并启动 Postgres 数据库，请运行：\n1  docker-compose up   或者，只提取支持 PostgreSQL 的 Umami Docker 映像：\n1  docker pull ghcr.io/mikecao/umami:postgresql-latest   或者使用支持 MySQL 的映像：\n1  docker pull ghcr.io/mikecao/umami:mysql-latest      📚 Umami 常见问题  1、Umami 是否符合 GDPR 标准？\n是符合的，Umami 不会收集任何个人身份信息，并且会匿名化收集所有数据。用户无法识别，也永远不会跨网站跟踪。\n2、我是否需要向用户显示 Cookie 通知？\n不，Umami 在跟踪代码中不使用任何 Cookie。\n3、Umami 是否适用于单页应用程序 （SPA）？\n是可以的，Umami 可以在 SPA 和普通网站之间无缝工作。\n4、Umami 可以记录按钮点击等事件吗？\n是的，请参阅 “入门” 下的 track-events。\n5、如果我遇到问题或想要请求功能，可以去哪里寻求帮助？\n对于一般讨论和故障排除，你可以使用 Github 上的讨论。\n有关错误报告和功能请求，请在 GitHub 上提交问题。\n为了获得最大的乐趣，请在Discord上加入 Umami 社区！\n   🧩 Umami 的技术栈   React - UI 框架 Next.js - React 框架 Prisma.io - 现代数据库访问工具包 Chart.js - 为设计师和开发人员提供简单而灵活的 JavaScript 图表 Redux - 用于 JS 应用程序的可预测状态容器 Formik -React 表单管理 react-spring - React 动画库     💫 Umami 的更新  为了获取最新的更新，请首先从 git 存储库中提取更改：\n1  git pull   然后安装任何新的或更新的依赖项：\n1  npm install   重新生成项目：\n1  npm run build   最后，启动应用程序：\n1  npm run start      👏 跟踪事件  除了页面浏览量，Umami 还可以跟踪网站上发生的事件。在 Umami 中记录事件有两种方法，使用 CSS 类或使用 Javascript。\n#1 使用 CSS 类\n要启用事件，只需向要跟踪的元素添加一个特殊的 CSS 类。\n假如你的代码中有如下按钮，需要添加跟踪事件：\n1  \u0026lt;button id=\u0026#34;signup-button\u0026#34; class=\u0026#34;button\u0026#34;\u0026gt;Sign up\u0026lt;/button\u0026gt;   添加以下格式的 class：\n1  umami--\u0026lt;event\u0026gt;--\u0026lt;event-name\u0026gt;   添加 class 后你的按钮就变成了下面这样：\n1  \u0026lt;button id=\u0026#34;signup-button\u0026#34; class=\u0026#34;button umami--click--signup-button\u0026#34;\u0026gt;Sign up\u0026lt;/button\u0026gt;   当用户单击此按钮时，Umami 将记录一个名为 signup-button 的事件，事件类型为 click。\n事件可以是任何可以应用于元素的 Javascript 事件。\n注意不要附加到任何连续触发的事件，如 scroll 和 drag。\n#2 使用 Javascript\n你还可以使用 window.umami 对象手动记录事件。要完成与上述 CSS 方法相同的任务，你可以执行以下操作：\n1 2 3  const button = document.getElementById(\u0026#39;signup-button\u0026#39;); button.onclick = () =\u0026gt; umami(\u0026#39;Signup button click\u0026#39;);   在这种情况下，Umami 将记录名为 Signup button click 的事件，事件类型为 custom。\n如果要使用自己的事件类型而不是 custom，请参阅 Tracker 函数。\n#3 查看事件\n一旦你的活动被记录下来，它们将出现在你的网站详细信息页面上。\n   🕶 跟踪器配置  Umami 跟踪器提供了几个属性，允许你配置其行为。\n#1 data-host-url\n默认情况下，Umami 会将数据发送到脚本所在的任何位置。你可以覆盖此选项以将数据发送到其他位置。\n用法：\n1 2 3 4 5  \u0026lt;script async defer src=\u0026#34;http://mywebsite/umami.js\u0026#34; data-website-id=\u0026#34;94db1cb1-74f4-4a40-ad6c-962362670409\u0026#34; data-host-url=\u0026#34;http://stats.mywebsite.com\u0026#34; \u0026gt;\u0026lt;/script\u0026gt;   #2 data-auto-track\n默认情况下，Umami 会自动为你跟踪所有页面浏览和事件。你可以禁用此行为，并使用跟踪器功能自己跟踪事件。\n用法：\n1 2 3 4 5  \u0026lt;script async defer src=\u0026#34;http://mywebsite/umami.js\u0026#34; data-website-id=\u0026#34;94db1cb1-74f4-4a40-ad6c-962362670409\u0026#34; data-auto-track=\u0026#34;false\u0026#34; \u0026gt;\u0026lt;/script\u0026gt;   #3 data-do-not-track\n你可以配置 Umami 以尊重访客的 “不跟踪” 设置。\n用法：\n1 2 3 4 5  \u0026lt;script async defer src=\u0026#34;http://mywebsite/umami.js\u0026#34; data-website-id=\u0026#34;94db1cb1-74f4-4a40-ad6c-962362670409\u0026#34; data-do-not-track=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/script\u0026gt;   #4 data-cache\n如果你从同一个用户那里获得了很多页面浏览量，例如在论坛网站上，你可以缓存一些数据来提高跟踪脚本的性能。\n注意：这将使用会话存储，因此你可能需要通知用户。\n用法：\n1 2 3 4 5  \u0026lt;script async defer src=\u0026#34;http://mywebsite/umami.js\u0026#34; data-website-id=\u0026#34;94db1cb1-74f4-4a40-ad6c-962362670409\u0026#34; data-cache=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/script\u0026gt;   #5 data-domains\n如果希望跟踪器仅在特定域上运行，可以将其添加到跟踪器脚本中。这是一个逗号分隔的域名列表。如果你在临时/开发环境中工作，则会有所帮助。\n1 2 3 4 5  \u0026lt;script async defer src=\u0026#34;http://mywebsite/umami.js\u0026#34; data-website-id=\u0026#34;94db1cb1-74f4-4a40-ad6c-962362670409\u0026#34; data-domains=\u0026#34;mywebsite.com,mywebsite2.com\u0026#34; \u0026gt;\u0026lt;/script\u0026gt;      ⛳ 跟踪器功能  Umami 跟踪器公开了一些功能，如果你想更好地控制跟踪，可以在网站上调用这些功能。\n#1 umami(event_value)\n发送事件类型为 custom 的事件。\n用法：\n1  umami(\u0026#39;Signup button click\u0026#39;);   #2 umami.trackEvent(event_value, event_type, [url], [website_id])\n跟踪具有自定义的事件类型的事件。\n用法：\n1  umami.trackEvent(\u0026#39;Signup button click\u0026#39;, \u0026#39;signup\u0026#39;, \u0026#39;/home\u0026#39;, \u0026#39;94db1cb1-74f4-4a40-ad6c-962362670409\u0026#39;);   url 和 website_id 值是可选的，默认为脚本定义的页面 url 和 data-website-id。\n#3 umami.trackView(url, [referrer], [website_id])\n跟踪页面视图。\n用法：\n1  umami.trackView(\u0026#39;/home\u0026#39;, \u0026#39;https://www.google.com\u0026#39;, \u0026#39;94db1cb1-74f4-4a40-ad6c-962362670409\u0026#39;);   referer 和 website_id 值是可选的，默认为脚本定义的 referer 和 website_id。\n   🦠 环境变量  .env 文件除了数据库中所需的 DATABASE_URL 和 HASH_SALT 变量之外，你可以使用一些附加变量来配置 Umami。\n#1 IGNORE_IP = \u0026lt;ip addresses\u0026gt;\n你可以提供一个以逗号分隔的 IP 地址列表，以从数据收集中排除。\n#2 FORCE_SSL = 1\n这将把所有请求从 http 重定向到 Umami 应用程序中的 https。注意，这不适用于跟踪脚本。\n#3 LOG_QUERY = 1\n如果你在开发模式下运行，这将把数据库查询记录到控制台进行调试。\n#4 HOSTNAME = \u0026lt;hostname\u0026gt;\n#5 PORT = \u0026lt;port number\u0026gt;\n如果你在需要绑定到特定主机名或端口（如 Heroku）的环境中运行，你可以添加这些变量，并使用 npm run start-env 而不是 npm start 启动应用程序。\n#6 CLIENT_IP_HEADER = \u0026lt;header name\u0026gt;\n用于检查客户端 IP 地址的 HTTP 标头。当你在使用非标准头的代理之后时，这很有用。\n#7 DISABLE_LOGIN = 1\n禁用应用程序的登录页面。\n#8 REMOVE_TRAILING_SLASH = 1\n从所有传入 URL 中删除尾部斜杠。\n#9 TRACKER_SCRIPT_NAME = \u0026lt;script name\u0026gt;\n允许你为跟踪器脚本指定自定义名称，默认值为 umami。如果你更新了此项，请确保将网站上的跟踪代码更新为新名称。\n#10 DISABLE_TELEMETRY = 1\n在安装过程中禁用完全匿名遥测数据的收集。\n以下是构建自定义 image\n必需的 docker 生成参数\n#1 BASE_PATH = \u0026lt;path\u0026gt;\n（可选）如果要在子目录下托管 Umami。仅用于在前端为 URL 添加前缀。可能需要使用反向代理删除 BASE_PATH 前缀，并将修改后的 URL 传递给 umami。\n#2 DATABASE_TYPE = postgresql | mysql\n（必需）要使用的 DB 类型。\n   🔗 应用程序接口  Umami 可以使用 API 接口来操作和读取数据，接口的路径为：http://\u0026lt;your-umami\u0026gt;/api 。\n你可以通过 Umami 管理面板执行的任何操作都可以在 API 中使用，但可能没有在此记录。\n#1 认证\n POST /api/auth/login\n 首先，你需要获取 token 才能发出 API 请求。你需要使用以下数据向 /api/auth/login 接口发出POST请求：\n1 2 3 4  { \u0026#34;username\u0026#34;: \u0026#34;your-username\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;your-password\u0026#34; }   如果成功，你应该得到如下响应：\n1 2 3  { \u0026#34;token\u0026#34;: \u0026#34;eyTMjU2IiwiY...4Q0JDLUhWxnIjoiUE_A\u0026#34; }   保存 token 值，并使用值 Bearer \u0026lt;token\u0026gt; 发送包含所有数据请求的 Authorization 标头。你的请求头应该如下所示：\n1  Authorization:Bearer eyTMjU2IiwiY...4Q0JDLUhWxnIjoiUE_A  例如，使用 curl 时，它将如下所示：\n1 2 3  curl https://yoursever/api/websites -H \u0026#34;Accept: application/json\u0026#34; -H \u0026#34;Authorization: Bearer \u0026lt;token\u0026gt;\u0026#34;   在 v1.26.0 之前，Umami 使用的是 cookies。如果使用旧版本，你的请求头应该是这样的：\n1  Cookie:umami.auth=eyTMjU2IiwiY...4Q0JDLUhWxnIjoiUE_A  认证后的其他接口使用请参考 Umami 官方：https://umami.is/docs/api\n","date":"07/06","permalink":"https://www.68wu.cn/post/tool/umami/","tags":["工具","Umami"],"title":"Umami 一款简单的网站流量分析平台"},{"categories":["Mysql"],"contents":"   🦄 什么是 MySQL ？  MySQL8 是 Oracle 公司推出的新款 MySQL Server ****版本，有着相比 MySQL5.7 版本更好的性能以及许多新特性。想要详细了解 MySQL8 请去查看中文版的详细介绍：⚜️传送门\n   🔖 为什么整理这篇文章？  这是我平常开发路上遇到的一些重复性的操作，为了能够在下次不必再网页中搜索信息而浪费时间，所以有了快捷手册这个分类，主要是记录一些重复性的流程，方便以后使用。🦖\n   🕵️‍♀️ 安装 MySQL8 的前期准备  #1. 下载适用于 windows 系统的 MySQL 程序。\n进入 MySQL 官方下载页面：传送门，根据下图指示下载 zip 文件。\n点击下方的链接就可以下载 MySQL 程序：\n#2. 把下载好的 zip 压缩包解压到 C 盘根目录，ps：你当然可以选择其他的路径来保存 MySQL 程序。\n#3. 进入到 MySQL 程序目录内，创建 my.ini 文件来对 MySQL 程序进行配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  [client]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置 3306 端口port = 3306# 设置 mysql 的安装目录basedir=C:\\\\mysql-8.0.29-winx64# 允许最大连接数max_connections=20# 服务端使用的字符集默认为 8 比特编码的 latin1 字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB  #4. 将 MySQL 程序的 bin 目录添加到环境变量。\n   💫 初始化 MySQL8  以管理员的身份运行 CMD 窗口。\n初始化 MySQL\n1  mysqld --initialize --console   注意，执行完后命令行界面会输出初始密码：\n1 2 3  ... 2022-07-05T02:41:14.632522Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: !pSImtu+r5:K ...   !pSImtu+r5:K 就是 MySQL root 用户的初始密码，之后登录进 MySQL 会要求修改密码，才可以执行其他命令。\n输入以下命令进行 MySQL 的安装：\n1  mysqld install      🌟 MySQL8 的启动与密码修改  启动 MySQL\n1  net start mysql   登录 MySQL\n1  mysql -u root -p   参数说明：\n h : 指定客户端所要登录的 MySQL 主机名, 登录本机 (localhost 或 127.0.0.1) 该参数可以省略; u : 登录的用户名; p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。  回车后，MySQL 会让你输入密码\n1  Enter password:   直接输入之前初始化产生的默认密码回车。\n登录成功后你将会看到 Welcome to the MySQL monitor... 的提示语。\n之后，你需要修改密码才能进行其他操作，修改密码的方式如下：\n1  ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY \u0026#39;新密码\u0026#39;;   出现执行成功：Query OK, 0 rows affected (0.02 sec)\n验证是否成功：\n1 2 3  # 登录 mysql -u root -p # 输入新的密码   🎉 恭喜你，到这里 MySQL8 的 Windows 安装之旅就结束啦！！！\n","date":"07/05","permalink":"https://www.68wu.cn/post/mysql/mysql8-windows-install/","tags":["Mysql","快捷手册"],"title":"MySQL8 的 Windows 安装详细流程"},{"categories":["Mysql"],"contents":"   一、新特性概述     1.1 更简便的 NoSQL 支持  NoSQL 泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。\n从 5.6 版本开始，MySQL 就开始支持简单的 NoSQL 存储功能。MySQL8 对这一功能做了优化，以更灵活的方式实现 NosQL 功能，不再依赖模式（schema）。\n   1.2 更好的索引  在查询中，正确地使用索引可以提高查询的效率，MySQL8 中新增了隐藏索引和降序索引，隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。\n   1.3 更完善的 JSON 支持  MySQL 从 5.7 开始支持原生 JSON 数据的存储，MySQL8 对这一功能做了优化，增加了聚合函数JSON_ARRAYAGG() 和 JSON_OBJECTAGG()，将参数聚合为 JSON 数组或对象，新增了行内操作符 -\u0026gt;\u0026gt; ，是列路径运算符 -\u0026gt; 的增强，对 JSON 排序做了提升，并优化了 JSON 的更新操作。\n   1.4 安全和账户管理  MySQL8 中新增了 caching_sha2_password 授权插件、角色、密码历史记录和 FIPS 模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。\n   1.5 InnoDB 的变化  InnoDB 是 MySQL 默认的存储引擎，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在 MySQL8 版本中，InnoDB 在自增、索引、加密、死锁、共享锁等方面做了大量的改进和优化，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。\n   1.6 数据字典  在之前的 MySQL 版本中，字典数据都存储在元数据文件和非事务表中。从 MySQL8 开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。\n   1.7 原子数据定义语句  MySQL8 开始支持原子数据定义语句（Automic DDL），即原子 DDL。目前，只有 InnoDB 存储引擎支持原子 DDL。原子数据定义语句（DDL）将与 DDL 操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。\n使用支持原子操作的存储引擎所创建的表，在执行 DROP TABLE、CREATE TABLE、ALTER TABLE、RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE 等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。\n对于从 MySQL5.7 复制到 MySQL8 版本中的语句，可以添加 IF EXISTS 或 IF NOT EXISTS 语句来避免发生错误。\n   1.8 资源管理  MySQL8 开始支持创建和管理资源组，玩许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。\n目前，CPU 时间是可控资源，由 “虚拟CPU” 这个概念来表示，此术语包含 CPU 的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有对应权限的数据库管理员可以将这些CPU 与资源组关联，并为资源组分配线程。\n资源组组件为 MySQL 中的资源组管理提供了 SQL 接口。资源组的属性用于定义资源组。MySQL 中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。\n在一些平台下，或进行了某些 MySQL 的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是 macOS 系统，资源管理将处于不可用状态。在 FreeBSD 和 Solaris 系统中，资源线程优先级将失效。在 LinuX 系统中，只有配置了 CAP_SYS_NICE 属性，资源管理优先级才能发挥作用。\n   1.9 字符集支持  MySQL8 中默认的字符集由 latin1 更改为 utf8mb4，并首次增加了日语所特定使用的集合， utf8mb4_ja_0900_as_cs。\n   1.10 优化器增强  MySQL 优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。\n   1.11 公用表表达式  公用表表达式（Common Table Expressions）简称为 CTE，MySQL 现在支持递归和非递归两种形式的 CTE。CTE 通过在 SELECT 语句或其他特定语句前使用 WITH 语句对临时结果集进行命名。 基础语法如下：\n1 2  WITH cte_name (col_name1,clo_name2..) AS (Suquery) SELECT * FROM cte_name;   Subquery 代表子查询,子查询前使用 WITH 语句将结果集命名为 cte_name，在后续的查询中即可使用 cte_name 进行查询。\n   1.12 窗口函数  MySQL8 开始支持窗口函数。在之前的版本中已存在的大部分聚合函数在 MySQL8 中也可以作为窗口函数来使用。\n   1.13 正则表达式支持  MySQL 在 8.0.4 以后的版本中采用支持 Unicode 的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的 Unicode 支持，而且是多字节安全编码。\nMySQL 增加了 REGEXP_LIKE()、EGEXP_INSTR()、REGEXP_REPLACE() 和 REGEXP_SUBSTRO() 等函数来提升性能。另外，regexp_stack_limit 和 regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。\n   1.14 内部临时表  empTable 存储引擎取代 MEMORY 存储引擎成为内部临时表的默认存储引擎。TempTable 存储引擎为 VARCHAR 和 VARBINARY 列提供高效存储。\ninternal_tmp_mem_storage_engine 会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable 和 MEMORY ，其中 TempTable 为默认的存储引擎。temptable_max_ram 系统配置项定义了 TempTable 存储引擎可使用的最大内存数量。\n   1.15 日志记录  在 MySQL8 中错误日志子系统由一系列 MySQL 组件构成。这些组件的构成由系统变量 log_error_services 来配置，能够实现日志事件的过滤和写入。\n   1.16 备份锁  新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。\n新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。\n   1.7 增强的 mysql 复制  MySQL8 复制支持对 JSON 文档进行部分更新的二进制日志记录，该记录使用紧凑的二进制格式，从而节省记录完整 JSON 文档的空间。\n当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的 binlog_row_value_options 系统变量值设置为 PARTIAL_JSON 来启用。\n   二、窗口函数     2.1 概念  MySQL 从 8.0 版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。\n   2.2 分类   静态窗口函数：静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同； 动态窗口函数：动态窗口函数的窗口大小会随着记录的不同而变化。     2.3 语法结构  1 2 3 4  #方式一 函数 OVER ([PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]) #方式二 函数 OVER 窗口名 ... WINDOW 窗口名 AS ([PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC])      2.4 举例  2.4.1 准备表与数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  CREATE TABLE goods ( id INT PRIMARY KEY AUTO_INCREMENT, category_id INT, category VARCHAR ( 15 ), NAME VARCHAR ( 30 ), price DECIMAL ( 10, 2 ), stock INT, upper_time DATETIME ); INSERT INTO goods ( category_id, category, NAME, price, stock, upper_time ) VALUES ( 1, \u0026#39;女装/女士精品\u0026#39;, \u0026#39;T恤\u0026#39;, 39.90, 1000, \u0026#39;2020-11-10 00:00:00\u0026#39; ), ( 1, \u0026#39;女装/女士精品 \u0026#39;, \u0026#39;连衣裙\u0026#39;, 79.90, 2500, \u0026#39;2020-11-10 00:00:00\u0026#39; ), ( 1, \u0026#39;女装/女士精品\u0026#39;, \u0026#39;卫衣\u0026#39;, 89.90, 1500, \u0026#39; 2020-11-10 00:00:00 \u0026#39; ), ( 1, \u0026#39;女装/女士精品\u0026#39;, \u0026#39;牛仔裤\u0026#39;, 89.90, 3500, \u0026#39;2020-11-10 00:00:00\u0026#39; ), ( 1, \u0026#39;女装/女士精品\u0026#39;,\u0026#39;百褶裙\u0026#39;,29.90,500,\u0026#39; 2020-11-10 00:00:00\u0026#39; ), ( 1, \u0026#39;女装/女士精品\u0026#39;, \u0026#39;呢绒外套\u0026#39;, 399.90, 1200, \u0026#39;2020-11-10 00:00:00\u0026#39; ), ( 2, \u0026#39;户外运动\u0026#39;, \u0026#39;自行车\u0026#39;, 399.90, 1000, \u0026#39;2020-11-10 00:00:00 \u0026#39; ), ( 2, \u0026#39;户外运动\u0026#39;, \u0026#39;山地自行车\u0026#39;, 1399.90, 2500, \u0026#39;2020-11-10 00:00:00\u0026#39; ), ( 2, \u0026#39;户外运动\u0026#39;, \u0026#39;登山杖\u0026#39;, 59.90, 1500, \u0026#39;2020-11-10 00:00:00\u0026#39; ), ( 2, \u0026#39;户外运动\u0026#39;, \u0026#39;骑行装备\u0026#39;, 399.90, 3500, \u0026#39;2020-11-10 00:00:00\u0026#39; ), ( 2, \u0026#39;户外运动\u0026#39;, \u0026#39;运动外套\u0026#39;, 799.90, 500, \u0026#39; 2020-11-10 00:00:00 \u0026#39; ), ( 2, \u0026#39;户外运动\u0026#39;, \u0026#39;滑板\u0026#39;, 499.90, 1200, \u0026#39; 2020-11-10 00:00:00\u0026#39; );\t  2.4.2 排序函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  #ROW NUMBER()函数：按PARTITION来给每个区添加顺序排序 #举例：查询goods数据表中每个商品分类下价格降序排列的各个商品信息。 SELECT ROW_NUMBER() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS row_num, id, category_id, category, NAME, price, stock FROM goods; #举例：查询goods数据表中每个商品分类下价格最高的3种商品信息。 SELECT * FROM ( SELECT ROW_NUMBER() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS row_num, id, category_id, category, NAME, price, stock FROM goods ) t WHERE row_num \u0026lt;= 3; #RANK()函数：按PARTITION来给每个区添加名次排序（并列第三就是1,2,3,3,5） #举例：使用RANK()函数获取goods数据表中各类别的价格从高到低排序的各商品信息。 SELECT RANK() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS row_num, id, category_id, category, NAME, price, stock FROM goods; # DENSE_RANK()函数：按PARTITION来给每个区添加排序（并列第三就是1,2,3,3,4） SELECT DENSE_RANK() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS row_num, id, category_id, category, NAME, price, stock FROM goods;   2.4.3 分布函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #分布函数 #PERCENT_RANK()函数:公式(rank -1)/(rows - 1) #举例：计算goods数据表中名称为“女装/女士精品\u0026#34;的类别下的商品的PERCENT_RANK值。 SELECT RANK() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS r, PERCENT_RANK() OVER ( PARTITION BY category_id ORDER BY price DESC ) AS pr, id, category_id, category, NAME, price, stock FROM goods WHERE category_id = 1; #CUME_DIST()函数:当前价格/区的最大价格 #举例：查询goods数据表中小于或等于当前价格的比例。 SELECT CUME_DIST() OVER ( PARTITION BY category_id ORDER BY price ASC ) AS cd, id, category, NAME, price FROM goods;   2.4.4 分布函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #LAG(expr,n)函数：返回当前行的前n行的expr值 #举例：查询goods数据表中前一个商品价格与当前商品价格的差值。 SELECT id, category, NAME, price, pre_price, price - pre_price AS diff_price FROM ( SELECT id, category, NAME, price, LAG( price, 1 ) OVER ( PARTITION BY category_id ORDER BY price ASC ) AS pre_price FROM goods WINDOW w AS ( PARTITION BY category_id ORDER BY price )) t; #其中，子查询是查询当前行数据 + 上一行价格 SELECT id, category, NAME, price, LAG( price, 1 ) OVER ( PARTITION BY category_id ORDER BY price ASC) AS pre_price FROM goods #LEAD(expr,n)函数：返回当前行的后n行的expr值 #举例：查询goods数据表中后一个商品价格与当前商品价格的差值。 SELECT id, category, NAME, price, behind_price, price - behind_price AS diff_price FROM ( SELECT id, category, NAME, price, LEAD( price, 1 ) OVER ( PARTITION BY category_id ORDER BY price ASC ) AS behind_price FROM goods WINDOW w AS ( PARTITION BY category_id ORDER BY price )) t;   2.4.4 首尾函数\n1 2 3 4 5 6 7 8 9 10 11 12 13  #FIRST_VALUE(expr)函数:返回第一个expr的值 #举例：按照价格排序，查询第1个商品的价格信息。 SELECT id, category, NAME, price, stock, FIRST_VALUE( price ) OVER w AS first_price FROM goods WINDOW w AS ( PARTITION BY category_id ORDER BY price ); #LAST_VALUE(expr)函数:返回最一个expr的值      2.5 常用窗口函数   排名函数：row_number()、rank()、dense_rank() 聚合函数：max()、min()、count()、sum()、avg()、median() 向前向后取值：lag()、lead() 百分位：percent_rank() 取值函数：first_value()、last_value()、nth_value() 分箱函数：ntile()     2.6 小结  窗口函数的特点是可以分组，而且可以在分组内排序。\n另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。\n   三、公用表表达式  公用表表达式（或通用表表达式）简称为 CTE（Common Table Expressions）。\nCTE 是一个命名的临时结果集，作用范围是当前语句，CTE 可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE 可以引用其他 CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。\n依据语法结构和执行方式的不同，公用表表达式分为普通公用表表达式和递归公用表表达式两种。\n   3.1 普通共用表达式  3.1.1 语法\n1 2 3  WITH CTE名称 AS (子查询) SELECT|DELETE|UPDATE 语句   3.1.2 举例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #子查询语句 SELECT * FROM departments WHERE department_id IN ( SELECT DISTINCT department_id FROM employees ); #普通公用表达式 WITH department_id_socpe AS ( SELECT DISTINCT department_id FROM employees ) SELECT * FROM departments d JOIN department_id_socpe d_s WHERE d.department_id = d_s.department_id;      3.2 递归公用表达式  3.2.1 语法\n1 2 3  WITH RECURSIVE CTE名称 AS (子查询) SELECT|DELETE|UPDATE 语句   3.2.2 举例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #递归公用表达式 WITH RECURSIVE cte AS ( SELECT employee_id, last_name, manager_id, 1 AS n FROM employees WHERE employee_id = 100 -- 种子查询，找到他的下下属 \tUNION ALL SELECT a.employee_id, a.last_name, a.manager_id, n + 1 FROM employees AS a JOIN cte ON ( a.manager_id = cte.employee_id ) -- 递归查询，找出以递归公用表达式的人为领导的人 \t) SELECT employee_id, last_name FROM cte WHERE n \u0026gt;= 3;   3.2.3 小结\n公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。\n————————————————\n版权声明：本文为CSDN博主「不入开发不工作」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_46245201/article/details/123002895\n","date":"07/05","permalink":"https://www.68wu.cn/post/mysql/mysql8-new-features/","tags":["Mysql","快捷手册"],"title":"MySQL8 的新特性：NoSQL、索引、账户管理、窗口函数..."},{"categories":["aria2中文手册"],"contents":"文章信息均来自 aria2 官网：aria2 和 开源仓库：https://github.com/aria2/aria2\n   👾 aria2 是什么？   aria2 是一个轻量级、多协议、多数据源的下载工具； aria2 支持的协议 HTTP/HTTPS、FTP、SFTP、BitTorrent 和 Metalink； aria2 可以从多个来源/协议下载文件，并尝试利用您的最大下载带宽，它支持同时从 HTTP（S）/FTP/SFTP 和 BitTorrent 下载文件，而从 HTTP（S）/FTP/SFTP 下载的数据上传到 BitTorrent 群，可以使用 Metalink 自动验证来自像 BitTorrent 文件这样的数据块； aria2 的使用者可以通过内置的 JSON-RPC 和 XML-RPC 服务进行操作，在操作时可以使用密钥保证操作者是有权限的；     ⬇️ 下载 aria2 的方法  在 aria2 仓库中发行的版本：aria2 最新发行版\n你可以直接下载适用于 Windows 和 Android 的源代码分发和二进制文件。\n   ✨ aria2 特点   命令行界面 支持 HTTP（S）、FTP、SFTP 和 BitTorrent 下载文件 分段下载 支持 Metalink version 4 （RFC 5854）（HTTP/FTP/SFTP/BitTorrent） 支持 Metalink version 3.0 （HTTP/FTP/SFTP/BitTorrent） 支持 Metalink/HTTP (RFC 6249) 实现 HTTP/1.1 支持 HTTP 代理 支持 HTTP Basic Authentication（HTTP基本认证） 支持 HTTP Proxy authentication（HTTP代理认证） 支持目前已知的代理环境变量，http_proxy https_proxy ftp_proxy all_proxyno_proxy 支持 HTTP gzip、deflate 内容编码 支持验证 HTTS 给定的 CA 证书 支持分块传输编码 支持从 Firefox3、Chromium、Google Chrome 和 Mozilla / Firefox（1.x / 2.x）/ Netscape格式中获取 Cookie 支持以 Mozilla/Firefox （1.x/2.x）/Netscape 格式保存 Cookie 支持自定义 HTTP 标头 支持持久链接 支持通过 HTTP 代理的 FTP/SFTP 限制上传/下载速度 BitTorrent 扩展：Fast extension, DHT, PEX, MSE/PSE, Multi-Tracker, UDP tracker BitTorrent WEB-Seeding。aria2 请求大于 piece size 的 chunks 以减少请求开销。它还支持 piece size 的流水线请求。 BitTorrent Local Peer Discovery 重命名/更改下载完成的 BitTorrent 目录结构 支持 JSON-RPC （通过 HTTP 和 WebSocket）/XML-RPC 服务接口 支持作为守护进程运行 支持在 multi-file torrent/Metalink 中选择下载 支持 Metalink 中的块校验和验证 支持在 Metalink 中禁用分段下载 支持 Netrc 支持配置文件 支持下载在文本文件和 stdin 中获取的 URIs，可以选择指定输出目录和文件名称 支持 Parameterized URI 支持 IPV6 支持 磁盘缓存以减少磁盘使用     🍂 版本控制和发布计划  我们对 aria2 版本使用 3 段数字：主要.次要.补丁。我们将在每月 15 号发布次要更新，如果自上次发布以来没有任何更改，我们可能会跳过一个版本。\n如果我们遇到安全问题，我们可能会在常规版本之间发布 补丁 版本。\n主要版本号我们暂时停留在 1 上。\n   🦋 许可证  这个程序是自由软件;您可以根据自由软件基金会发布的 GNU 通用公共许可证的条款重新分发和/或修改它;许可证的版本 2，或（由您选择）任何更高版本。\n   🐎 使用示例  命令行吓到你了？不要慌，aria2 真的很容易使用。\n从 WEB 下载文件：\n1  aria2c http://example.org/mylinux.iso   一次性使用不同的协议下载多个文件：\n1  aria2c http://a/f.iso ftp://b/f.iso   每个 Host 使用两个链接下载：\n1  aria2c -x2 http://a/f.iso   BitTorrent：\n1  aria2c http://example.org/mylinux.torrent   BitTorrent 磁力链接：\n1  aria2c \u0026#39;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C\u0026#39;   Metalink：\n1  aria2c http://example.org/mylinux.metalink   下载文本文件中的 URIs：\n1  aria2c -i uris.txt      怎么获取源代码？  我们在Github上维护源代码：https://github.com/aria2/aria2\n若要获取最新的源代码，请运行以下命令：\n1  git clone https://github.com/aria2/aria2.git   这将在当前目录中创建 aria2 目录，源文件将存储在那里。\n   依赖     特点 依赖     HTTPS OSX or GnuTLS or OpenSSL or Windows   SFTP libssh2   BitTorrent None. Optional: libnettle+libgmp or libgcrypt or OpenSSL (see note)   Metalink libxml2 or Expat.   Checksum None. Optional: OSX or libnettle or libgcrypt or OpenSSL or Windows (see note)   gzip, deflate in HTTP zlib   Async DNS C-Ares   Firefox3/Chromium cookie libsqlite3   XML-RPC libxml2 or Expat.   JSON-RPC over WebSocket libnettle or libgcrypt or OpenSSL    注意\n如果安装了两个库，则 libxml2 优先于 Expat。如果您更喜欢 Expat，请运行 --without-libxml2\n注意\n在 Apple OSX 上支持系统级的 SSL/TLS。因此，在该平台上既不需要 GNUTL 也不需要 OpenSSL 。如果要禁用此行为，请运行 --without-appletls\n如果安装了两个库，则 GnuTLS 优先于 OpenSSL。如果您喜欢 OpenSSL，请运行 --without-gnutls --with-openssl\n在 Windows 上，可以使用基于本机 Windows SSL 功能（Schannel）的 SSL 实现，这将是首选。因此，在该平台上既不需要 GNUTL 也不需要 OpenSSL 。如果要禁用此行为，请运行 --without-wintls\n注意\n在 Apple OSX 上，系统级校验和支持将是首选，除非 aria2 配置为 --without-appletls\n如果安装了两个库，则 libnettle 优先于 libgcrypt。如果您更喜欢 libgcrypt，请运行--without-libnettle --with-libgcrypt。如果在 GNUTL 上选择 OpenSSL，则不会使用 libnettle 或 libgcrypt。\n如果没有安装任何可选依赖项，则将使用仅支持 md5 和 sha1 的内部实现。\n在 Windows 上，可以使用基于本机 Windows 功能的 SSL 实现，除非 aria2 配置为 --without-wintls\n用户可以具有以下 SSL 和 crypto libraries 配置之一：\n OpenSSL GnuTLS + libgcrypt GnuTLS + libnettle Apple TLS (OSX only) Windows TLS (Windows only)  在运行时可以提供--disable-bittorrent和 --disable-metalink 来禁用 BitTorrent 和 Metalink 的支持。\n为了启用异步 DNS 支持，你需要 c-ares。\n c-ares: http://c-ares.haxx.se/     如何构建（build）  aria2 主要用 C++ 编写，最初它是基于 C++98/C++03 标准特性编写的。我们现在正在将 aria2 迁移到 C++11 标准。当前的源代码需要支持 C++11 的编译器。对于众所周知的编译器，例如 g++ 和clang，必须支持 or flag。-std=c++11-std=c++0x\n为了从源软件包构建 aria2，您需要以下开发软件包（软件包名称可能因您使用的发行版而异）：\n libgnutls-dev (Required for HTTPS, BitTorrent, Checksum support) nettle-dev (Required for BitTorrent, Checksum support) libgmp-dev (Required for BitTorrent) libssh2-1-dev (Required for SFTP support) libc-ares-dev (Required for async DNS support) libxml2-dev (Required for Metalink support) zlib1g-dev (Required for gzip, deflate decoding support in HTTP) libsqlite3-dev (Required for Firefox3/Chromium cookie support) pkg-config (Required to detect installed libraries)  您可以使用 libgcrypt-dev 而不是 nettle-dev 和 libgmp-dev：\n libgpg-error-dev (Required for BitTorrent, Checksum support) libgcrypt-dev (Required for BitTorrent, Checksum support)  您可以使用 libssl-dev 而不是 libgnutls-dev、nettle-dev、libgmp-dev、libgpg-error-dev 和 libgcrypt-dev：\n• libssl-dev (Required for HTTPS, BitTorrent, Checksum support)\n您可以使用 libexpat1-dev 而不是 libxml2-dev：\n• libexpat1-dev (Required for Metalink support)\n在 Fedora 上，您需要以下软件包：gcc, gcc-c++, kernel-devel, libgcrypt-devel, libxml2-devel, openssl-devel, gettext-devel, cppunit\n如果您从 git 存储库下载了源代码，则必须安装以下软件包才能获得 autoconf macros。\n libxml2-dev libcppunit-dev autoconf automake autotools-dev autopoint libtool  并运行以下命令以生成配置脚本和生成程序所需的其他文件：\n1  autoreconf -i   此外，您还需要 Sphinx 来构建手册页。\n如果您正在为 Mac OS X 构建 aria2，请查看 makerelease-osx.mk GNU Make makefile。\n构建 aria2 的最快方法是首先运行配置脚本：\n1  ./configure   要构建静态链接的 aria2，请使用命令行选项：ARIA2_STATIC=yes\n1  ./configure ARIA2_STATIC=yes   配置完成后，运行编译程序：make\n1  make   请看交叉编译 Windows 二进制文件来进行 Windows 的交叉编译;\n请看交叉编译 Android 二进制文件来进行 Android 的交叉编译;\nconfigure 会检查可用库并启用尽可能多的功能，在 default 下未启用的实验功能除外。\n从 1.1.0 开始，aria2 默认检查 HTTPS 服务器的证书。如果您使用 OpenSSL 或具有 gnutls_certificate_set_x509_system_trust() 功能的最新版本的 GnuTLS 进行构建，并且库已正确配置以定位系统范围的 CA 证书存储，aria2 将在启动时自动加载这些证书。如果不是这样，我建议提供 CA 包文件的路径，例如在Debian中，CA 捆绑文件的路径是 \u0026lsquo;/etc/ssl/certs/ca-certificates.crt\u0026rsquo; (in ca-certificates package)，这可能因您的发行版本而异，您可以使用 configure 的 --with-ca-bundle option :\n1 2  ./configure --with-ca-bundle=\u0026#39;/etc/ssl/certs/ca-certificates.crt\u0026#39; make   如果没有 --with-ca-bundle 选项，则在访问 HTTPS 服务器时会遇到错误，因为没有 CA bundle 无法验证证书。在这种情况下，可以使用 aria2 的 --ca-certificate 指定 CA 捆绑文件。如果没有安装 CA bundle 文件，那么最后一种方法是使用 --check-certificate=false 禁用证书验证。\n使用本机 OSX（AppleTLS）和 / 或 Windows（WinTLS）实现将自动使用系统证书存储，因此，不需要使用 -with-ca-bundle，在使用这些实现时将被忽略。\n默认情况下 aria2c 安装在名为 bash_completion 的目录中，其位置在 $prefix/share/doc/aria2/bash_completion。要更改文件的安装目录，请使用 --with-bashcompletiondir 选项。\nmake 后，可执行文件位于src/aria2c。\naria2 使用 CppUnit 进行自动单元测试。要运行单元测试：\n1  make check      交叉编译 Windows 二进制文件  在本节中，我们将介绍如何在 Debian Linux 上使用 mingw-w64 （http://mingw-w64.org/doku.php ） 交叉编译器构建 Windows 二进制文件，MinGW（http://www.mingw.org/ ）可能无法 aria2。\n构建 Windows 二进制文件的最简单方法是使用 Dockerfile，请参考 Dockerfile.mingw 来构建二进制文件，如果您不能使用 Dockerfile 请继续阅读以下内容。\n基本上，在编译和安装依赖库之后，您可以进行交叉编译，只需传递适当的 --host 选项并指定要配置的 CPPFLAGS LDFLAGS PKG_CONFIG_LIBDIR 变量。为了方便和降低我们自己的开发成本，我们提供了更简单的方法来配置构建设置。\nmingw-config 脚本是用于 mingw-w64 的 configure 脚本包装器。我们使用它来创建正式的 Windows 版本。此脚本假设已为交叉编译构建以下库：\n c-ares expat sqlite3 zlib libssh2 cppunit  可以调整某些环境变量以更改生成设置：\nHOST\n通过 HOST 环境变量可以编译为 HOST 指定的系统，它默认为 i686-w64-mingw32 ，要生成64位二进制文件，请指定为 x86_64-w64-mingw32 。\nPREFIX\nPREFIX 是安装依赖库的目录的前缀，默认为 /usr/local/$HOST ，I$PREFIX/include 将添加到 CPPFLAGS ，L$PREFIX/lib 将添加到 LDFLAGS ，$PREFIX/lib/pkgconfig 将添加到 PKG_CONFIG_LIBDIR 。\n例如，要构建64位二进制文件，请执行以下操作：\n1  HOST=x86_64-w64-mingw32 ./mingw-config   如果您想使用 libaria2 dll 可以指定 --enable-libaria2 ，然后不要使用 ARIA2_STATIC=yes 并准备外部库的 DLL 版本。\n   交叉编译 Android 二进制文件  在本节中，我们将介绍如何在 Debian Linux 上使用 Android NDK 交叉编译器构建 Android 二进制文件。\n在撰写本文时，Android NDK r21e 应该可以无误的编译 aria2。\nandroid-config 脚本是 Android build 的配置脚本包装器，我们用它来创建正式的 Android 版本，此脚本假设已为交叉编译构建以下库：\n c-ares openssl expat zlib libssh2  在构建上述库时，请确保禁用共享库并仅启用静态库，我们将静态链接这些库。\nandroid-config 假设定义了 $ANDROID_HOME 和 $NDK 环境变量。\n我们目前使用 Android NDK r21e，$NDK 应指向 Anroid NDK 的目录，构建工具位于 $NDK/toolchains/llvm/prebuilt/linux-x86_64/bin/ 。\n所有依赖库必须安装在 $ANDROID_HOME/usr/local 。\n在 android-config 之后，运行 make 编译源代码。\n   构建文档  Sphinx 用于构建文档。如果 aria2 手册页不是最新的，则会在运行 make 时生成。您还可以通过生成 HTML 来构建 aria2 手册页的 HTML 版本。HTML 版本手册也可在线获取（俄语翻译、葡萄牙语翻译）。\n   BitTorrent  关于文件名\n下载文件的文件名确定如下：\n 单文件模式  如果 “name” 键存在于 .torrent 文件中，则文件名是 “name” 键的值。\n否则，文件名就是 BitTorrent 的文件名称加上 “.file” ，例如 BitTorrent 的文件名称是 “test.torrent”，那么下载的文件名就是 “test.torrent.file”，下载文件的目录可以通过 -d 选项指定。\n 多文件模式  .torrent 文件内部已存在目录结构，所以 aira2 直接按照已有的结构创建文件和目录，下载文件的根目录可以通过 -d 选项指定。\n在下载开始之前，如果需要，将创建一个完整的目录结构。\n默认情况下 aria2 最多从 .torrent 中同时打开 100 个文件，并直接写入和读取这些文件。\n要修改 aria2 同时打开文件的数量，请指定 --bt-max-open-files 选项。\n   DHT  aria2 支持与主线兼容的DHT。\n默认情况下，IPv4 DHT的路由表保存到 $XDG_CACHE_HOME/aria2/dht.dat，dat 和 IPv6 DHT 的路由表保存到 $XDG_CACHE_HOME/aria2/dht6.dat。除非文件存在于 $HOME/.aria2/dht.dat or $HOME/.aria2/dht6.dat 。\naria2 使用相同的端口号侦听 IPv4 和 IPv6 DHT。\n   UDP tracker  启用 IPv4 DHT 时，将启用 UDP 跟踪器支持。UDP 跟踪器的端口号与 DHT 共享。\n使用 --dht-listen-port 选项更改端口号。\n   Metalink  当前的实现支持 HTTP（S）/FTP/SFTP/BitTorrent，其他 P2P 协议被忽略，支持 Metalink4（RFC 5854）和 Metalink 3.0 版文档。\n对于校验和验证，支持 md5、sha-1、sha-224、sha-256、sha-384 和 sha-512，如果提供了多个哈希算法，aria2 将使用更强的哈希算法，如果整个文件校验和验证失败，aria2 不会重试下载，只会以非零返回代码退出。\n支持用户的首选项包括：version, language, location, protocol and os。\n如果 Metalink 文件中提供了块校验和，aria2 会在下载过程中自动验证数据块，此行为可以通过命令行选项关闭。\n如果签名包含在 Metalink 文件中，aria2 会在下载完成后将其保存为文件，文件名为下载文件名+“.sig”。如果同一文件已存在，则不会保存签名文件。\n在 Metalink4 中，多文件 torrent 可能出现在 metalink:metaurl 元素中，由于 aria2 无法同时下载两个相同的 Torrent，aria2 将文件分组在 metalink 中：文件元素具有相同的 BitTorrent metaurl，并从单个 BitTorrent swarm 下载。\n这基本上是带有文件选择的多文件 torrent 下载，因此也会创建不在 Metalink 文档中但与所选文件共享同一部分的相邻文件。\n如果在 metalink:url 或 metalink:metaurl 元素中指定了相对 URI，则 aria2 使用 metalink 文件的 URI 作为基本 URI 来解析相对 URI。如果在从本地磁盘读取的 Metalink 文件中找到相对 URI，则 aria2 使用 --metalink-base-uri 选项的值作为基本 URI。如果未指定此选项，则将忽略相对 URI。\n   Metalink/HTTP  Metalink/HTTP 的实现仅限于 rel=duplicate 的链接。\naria2 解析 Digest header 字段，并检查它是否与其他来源的 digest 值匹配。如果不同，就断开连接，aria2 还使用此 Digest 值在下载完成后执行校验和验证。\n让 aria2 知道优先使用的 metalink 地址，可以使用 --metalink-location 选项。\n   netrc  默认情况下，HTTP/FTP/SFTP 支持 netrc，要禁用 netrc 支持，请指定 -n 命令行选项\n你的 netrc 文件应具有相应的权限：（600）。\n   WebSocket  aria2 中嵌入的 WebSocket 服务器实现了 RFC 6455 中定义的规范。支持的协议版本为 13。\n   libaria2  libaria2 是一个 C++ 库，它为客户端的开发提供 aria2 功能。\n目前，libaria2 不是默认构建的，要启用 libaria2，请使用 --enable-libaria2 配置选项。\n默认情况下，只生成共享库，要构建静态库，还可以使用 --enable-static 配置选项。\n了解如何使用API，请参阅 libaria2 文档。\n   aria2 开发时的参考   aria2 Online Manual https://aria2.github.io/ RFC 959 FILE TRANSFER PROTOCOL (FTP) RFC 1738 Uniform Resource Locators (URL) RFC 2428 FTP Extensions for IPv6 and NATs RFC 2616 Hypertext Transfer Protocol \u0026ndash; HTTP/1.1 RFC 3659 Extensions to FTP RFC 3986 Uniform Resource Identifier (URI): Generic Syntax RFC 4038 Application Aspects of IPv6 Transition RFC 5854 The Metalink Download Description Format RFC 6249 Metalink/HTTP: Mirrors and Hashes RFC 6265 HTTP State Management Mechanism RFC 6266 Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP) RFC 6455 The WebSocket Protocol RFC 6555 Happy Eyeballs: Success with Dual-Stack Hosts The BitTorrent Protocol Specification BitTorrent: DHT Protocol BitTorrent: Fast Extension BitTorrent: IPv6 Tracker Extension BitTorrent: Extension for Peers to Send Metadata Files BitTorrent: Extension Protocol BitTorrent: Multitracker Metadata Extension BitTorrent: UDP Tracker Protocol for BitTorrent and BitTorrent udp-tracker protocol specification. BitTorrent: WebSeed - HTTP/FTP Seeding (GetRight style) BitTorrent: Private Torrents BitTorrent: BitTorrent DHT Extensions for IPv6 BitTorrent: Message Stream Encryption Kademlia: A Peer-to-peer Information System Based on the XOR Metric  ","date":"07/04","permalink":"https://www.68wu.cn/post/aria2/aria2-chinese-manual-1/","tags":["aria2","快捷手册","aria2中文手册"],"title":"aria2 中文手册（一）-详细介绍、编译、交叉编译"},{"categories":["Golang"],"contents":"在 windows 下跨卷使用 os.Rename 时会报错：golang cannot move the file to a different disk drive.\n不能直接跨卷/分区使用，可以使用以下方法实现跨卷/分区的文件移动。\n实现逻辑：在目标位置新建一个空文件，使用 io.Copy 拷贝数据到新文件里后，删除源文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // MoveFile 实现跨卷/分区移动文件 func MoveFile(sourcePath, destPath string) error { inputFile, err := os.Open(sourcePath) if err != nil { return fmt.Errorf(\u0026#34;Couldn\u0026#39;t open source file: %s\u0026#34;, err) } outputFile, err := os.Create(destPath) if err != nil { inputFile.Close() return fmt.Errorf(\u0026#34;Couldn\u0026#39;t open dest file: %s\u0026#34;, err) } defer outputFile.Close() _, err = io.Copy(outputFile, inputFile) inputFile.Close() if err != nil { return fmt.Errorf(\u0026#34;Writing to output file failed: %s\u0026#34;, err) } // The copy was successful, so now delete the original file \terr = os.Remove(sourcePath) if err != nil { return fmt.Errorf(\u0026#34;Failed removing original file: %s\u0026#34;, err) } return nil }   ","date":"06/20","permalink":"https://www.68wu.cn/post/golang/file-move/","tags":["Golang","小问题","Rename"],"title":"golang os.Rename 时出现错误，不能跨磁盘移动文件解决方法！"},{"categories":["Hugo"],"contents":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  --- # author 作者 author: \u0026#34;Hugo Authors\u0026#34; # title 内容标题 title: \u0026#34;Hugo 文件的前置参数\u0026#34; # description 描述 description: \u0026#34;这是使用 hugo 编写 markdown 文章时所有内置的参数，整理出来方便以后查找使用。\u0026#34; # tags 内容标签 tags: [\u0026#34;hugo\u0026#34;, \u0026#34;快捷手册\u0026#34;] # lastmod 上次修改时间 lastmod: \u0026#34;2022-05-27\u0026#34; # date 内容排序时间 date: \u0026#34;2022-05-27\u0026#34; # weight 用于排序 weight: 1 # 文章分类 categories: - \u0026#34;Hugo\u0026#34; ---   ","date":"05/27","permalink":"https://www.68wu.cn/post/hugo/front-matter/","tags":["hugo","快捷手册"],"title":"Hugo 文件的前置参数"},{"categories":null,"contents":"EOF\n","date":"01/01","permalink":"https://www.68wu.cn/articles/","tags":null,"title":"文章"},{"categories":null,"contents":"EOF\n","date":"01/01","permalink":"https://www.68wu.cn/projects/","tags":null,"title":"项目"}]